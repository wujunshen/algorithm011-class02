# 学习笔记

## Tire树

### 基本概念

多个名字：
* 字典树
* 单词查找树
* 键树

树形结构用于统计和排序大量字符串(不限于字符串)，使用场景是搜索引擎系统用来做文本词频统计

优点是最大限度减少无谓字符串比较，查询效率比哈希表高

## 分析单词搜索II用Tire树方式实现的时间复杂度

Tire树时间复杂度只跟字符串长度有关，所以时间复杂度为O(m)，分析单词搜索II中整个board二维数组元素都是一个个字母，因此时间复杂度最多算O(m* n)

## 并查集

### 使用场景

集合运算，group操作

### 基本操作

* makeSet(s)
  建立新并查集，其中包含s个元素
* unionSet(x,y)
  把元素x和元素y所在集合合并，要求x和y所在集合不相交，若相交则不合并
* find(x) 
  找到元素x所在集合代表。也用于判断两个元素是否位于同一个集合，只要将各自代表比较一下就行了


## 启发式算法

相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。

启发式算法可以这样定义

一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计

## 剪枝

剪枝策略就是在搜索过程中利用过滤条件来剪去完全不用考虑（已经判断这条路走下去也得不到最优解）的搜索路径，从而避免一些不必要的搜索，大大优化算法求解速度，还保证了结果的正确性

应用到回溯算法中，我们就可提前判断当前路径是否能产生结果集，如果否，就可提前回溯。而这也叫做可行性剪枝

另外还有一种叫最优性剪枝，每次记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯

## 双向BFS

双向BFS主要是起点和终点一起遍历，并给数组多加一维。因为双向的最短路径一定是整体的最短路径，即搜索到一个点另一个也已被搜索到，直接输出即可。

### 优点

考虑广度优先遍历，越到后面的层数，常数越大，如果采用双向BFS可以使常数大大减小，从而起到降低时间复杂度的作用

### 和单向区别

可从终点和起点同时出发，记录每个点是从起点开始的访问（开一个vis数组，参考dfs），还是从终点开始的访问，如果访问到一个点，同时是起点开始和终点开始的访问了，那么这个点就是答案的必经点，输出起点终点路径之和就行

## A*算法

### 启发式函数
h(n),用来评价哪些结点最有希望是一个我们要找的结点，它会返回一个非负实数，也可认为是从结点n的目标结点路径的估计成本

它是一种告知搜索方向的方法，它提供了一种明智方法来猜哪个邻居结点会导向目标

### 基本思路

#### 1.把起点加入 open list

#### 2.重复如下过程
##### 2.1 遍历open list ，查找F值最小的节点，把它作为当前要处理的节点，然后移到close list中
##### 2.2 对当前方格的 8 个相邻方格一一进行检查，如果它是不可抵达的或者它在close list中，忽略它。否则，做如下操作

* 如果它不在open list中，把它加入open list，并且把当前方格设置为它的父亲

* 如果它已经在open list中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更近。如果更近，把它的父亲设置为当前方格，并重新计算它的G和F值。如果你的open list是按F值排序的话，改变后你可能需要重新排序

##### 2.3 遇到下面情况停止搜索
       
   * 把终点加入到了 open list 中，此时路径已经找到了，或
    
   * 查找终点失败，并且open list 是空的，此时没有路径
#### 3.从终点开始，每个方格沿着父节点移动直至起点，形成路径

